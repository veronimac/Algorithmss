# В условии сказано, что s - валидная строка, следовательно закрывающая скобка на первом или рандомном месте в строке
# встречаться не будет, могу не проверять строку на это
# Решать буду через стек, нужно считать открывающие скобки в моменте. И декрементировать счетчик, если скобка ). Ведь пара уже точно будет
# Сложность O(n) т.к. просто перебор элементов


class Solution:
    def removeOuterParentheses(self, s: str) -> str:
        stack = []                  # создаю пустой стек
        answer = ""                 # ответ - пока что пустая строка
        counter = 0                 # счетчик для скобок, которые нужно закрыть (если пара найдется, то декрементируем,
                                    # если пара еще не нашлась, то инкрементируем)
        for x in s:                 # прохожусь по строке со скобками
            if x == "(":            # если скобка открывающая
                stack.append(x)     # добавляю ее в стек
                counter += 1        # счетчик +1
            if counter > 1:         # если счетчик больше 1, следовательно, у нас есть незакрытая скобка
                answer += "("       # добавляем ее в стек

            if x == ")":            # если скобка закрывающаяся
                stack.pop(-1)       # из стека ее удаляю
                counter -= 1        # счетчик -1 т.к. нашли закрывающую скобку
                if counter > 0:     # если счетчик больше одного, то есть все еще осталась открывающая скобка после удаления
                                    # последнего элемента стека
                    answer += ")"   # поэтому в ответ вносим закрывающую скобку

        return answer               # возвращаю ответ (валидные внутренние скобки)

